1、散列表（hash表或哈希表）定义：
     散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，
     如果没有数组，就没有散列表（就是传说中的key-value结构）

2、散列表实现原理：
     散列值（hash值） = hash(key)。其中hash(key)是散列函数，key是键或者关键字，散列值是数组下标，将value存在该下标中

3、散列函数要求：
（1）散列值必须是非负整数，
（2）同一个key经过散列函数，返回结果必须相同
（3）不同的key经过散列函数，返回的结果必须不同
（很难实现，著名的MD5,SHA,CRC等哈希算法，也做无法做到到）这也是散列冲突存在的原因

4、散列冲突
     不同的key经过散列函数，返回了相同的散列值即散列冲突，同时因为数组的存储空间有限，也会加大散列冲突的概率

5、解决散列冲突的方法
（1）开放寻址法：
         a、线性探索：
              插入：当一个新key通过散列函数计算得到的散列值，在数组已经存在了数据（即发生散列冲突）从的散列值向后查找空闲位置，
                        如果找到则将新key对应的value插入到刚找到的空闲位置，如果查到数组末尾还没查到空闲位置，则继续从数组头开始遍历
                        到散列值位置，如果找到则插入，如果认为找到则说明散列表已满。
              查找：我们通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素。如果相等，
                        则说明就是我们要找的元素；否则就顺序往后依次查找。如果遍历到数组中的空闲位置，还没有找到，就说明要查找的元素
                        并没有在散列表中
              删除：删除操作稍微有些特别。我们不能单纯地把要删除的元素设置为空，而是特殊标记为 deleted。当线性探测查找的时候，
                        遇到标记为 deleted 的空间，并不是停下来，而是继续往下探测。
             缺点：当散列表中插入的数据越来越多时，散列冲突发生的可能性就会越来越大，空闲位置会越来越少，线性探测的时间就会越
                       来越久。极端情况下，我们可能需要探测整个散列表，所以最坏情况下的时间复杂度为 O(n)。同理，在删除和查找时，
                       也有可能会线性探测整张散列表，才能找到要查找或者删除的数据

       b、二次探索：
            跟线性探测很像，线性探测每次探测的步长是 1，那它探测的下标序列就是 hash(key)+0，hash(key)+1，hash(key)+2……
            而二次探测探测的步长就变成了原来的“二次方”，也就是说，它探测的下标序列就是 hash(key)+0，hash(key)+12，hash(key)+22……
       c、双重散列：
            意思就是不仅要使用一个散列函数。我们使用一组散列函数 hash1(key)，hash2(key)，hash3(key)……我们先用第一个散列函数，
            如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置
      注：
           不管采用哪种探测方法，当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高。为了尽可能保证散列表的操作效率，
           一般情况下，我们会尽可能保证散列表中有一定比例的空闲槽位。我们用装载因子（load factor）来表示空位的多少。
           装载因子:填入表中的元素个数/散列表的长度

         开放寻址法优点：可以有效地利用 CPU 缓存加快查询速度，序列化简单

         开放寻址法缺点：删除数据的时候比较麻烦，需要特殊标记已经删除掉的数据。而且，在开放寻址法中， 所有的数据都存储在一个数组中，
                                    比起链表法来说，冲突的代价更高。所以，使用开放寻址法解决冲突的散列表，装载因子的上限不能太大。这也导致这种
                                    方法比链表法更浪费内存空间
        开放寻址法使用场景：当数据量比较小、装载因子小的时候，适合采用开放寻址法。这也是 Java 中的ThreadLocalMap使用开放寻址法解决散列
                                        冲突的原因

（2）链表法：链表法是一种更加常用的散列冲突解决办法，相比开放寻址法，它要简单很多。我们来看这个图，在散列表中，
                       每个“桶（bucket）”或者“槽（slot）”会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中
        链表法优点：
            （1）链表法对内存的利用率比开放寻址法要高
            （2）对大装载因子的容忍度更高
        链表法缺点：
            （1）链表因为要存储指针，所以对于比较小的对象的存储，是比较消耗内存的
            （2）链表中的结点是零散分布在内存中的，不是连续的，所以对 CPU 缓存是不友好的，这方面对于执行效率也有一定的影响
        链表法优化：可以把链表法中的链表换成跳表、红黑树等动态数据结构，即便出现散列冲突，极端情况下，所有的数据都散列
                             到同一个桶内，那最终退化成的散列表的查找时间也只不过是 O(logn)。这样也就有效避免了前面讲到的散列碰
                             撞攻击
        链表法应用场景：基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵
                                   活，支持更多的优化策略，比如用红黑树代替链表
6、散列函数的设计
     （1）散列函数的设计不能太复杂
     （2）散列函数生成的值要尽可能随机并且均匀分布
     （3）散列函数的设计方法：直接寻址法、平方取中法、折叠法、随机数法等

7、装载因子过大时：（装载因子阈值）
     动态扩容（此应该应该从新计算数组下标，在进行搬移），动态缩容与之想反
8、如何避免低效地扩容
    当装载因子达到阈值时，扩容但不搬移数据，每次插入新的数据时，将新的数据插入新的空间，并从老的空间拿出一个放到新的空间
  （分散搬移），直到老的被办完在释放掉， 当查找时先从新空间查找在到老空间查找















